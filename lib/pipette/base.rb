
class Pipette < Thor
  class << self
    # Provide the order of the steps to execute
    #   steps :one, :two, :three
    # ==== Parameters
    # Array[Symbol]
    #
    def steps(*step_list)
      @steps ||= []
      steps = [step_list].flatten
      @steps = steps unless steps.empty?
      @steps
    end

    # Provide mechanism to specify what inputs are required by this step.
    # provide input name and options (see Thor method_option for details on options.
    # The input of steps will be populated by the hash of output generated by the previous step(s).
    # ==== Parameters
    # Symbol, Hash of options
    #
    # ==== Returns
    # Array of names of current inputs
    #
    def input(name = nil, options = {})
      @inputs ||= []
      if name
        raise "ERROR: cannot use same input twice" if @inputs.include? name
        options[:required => true]
        @inputs << name
        method_option(name, options)
      end
      @inputs
    end

    def output #:nodoc:
      @output ||= {}
    end
  end

  def initialize(args=[], options={}, config={}) #:nodoc:
    super(args,options,config)
  end

  no_tasks do # hide from base Thor
    # Returns the steps for this pipeline
    #
    # ==== Returns
    # Array[Symbol]
    #
    def steps
      self.class.steps
    end

    # Returns the steps to be executed in this
    # run of the pipeline. By default, all steps
    # are executed in the order they are provided.
    # You can limit the steps to be run via options
    # to the start task
    #
    # ==== Returns
    # Array[Symbol]
    #
    def valid_steps
      @valid_steps ||= self.steps
    end

    # Set valid steps for the run
    # This method will transform string steps to
    # symbol steps. if input is nil, valid steps
    # are not changed
    #
    # ==== Parameters
    # Array[Symbol|String]
    #
    def valid_steps= valid_steps
      unless valid_steps.nil?
        valid_steps = valid_steps.collect {|s| s.to_sym}
        valid_steps = steps.select {|s| valid_steps.include? s}
        @valid_steps = valid_steps
      end
    end

    # Returns hash of input parameters defined for this step.
    # Input parameters are really just options that we track
    # separately. Define an input for a task using the
    # input method at the Pipette level. This works the same
    # as the method_options method
    #
    # ==== Returns
    # Hash of options
    #
    def input
      self.options.select {|key, value| self.class.input.include? key.to_sym}
    end

    # Returns hash to store output parameters with.
    # Values in output will be passed to the next step as input.
    # This allows us to ensure that the input for a step is satisfied by the previous step(s) output.
    #
    # ==== Returns
    # Hash to store outputs to
    def output
      self.class.output
    end
  end
end
